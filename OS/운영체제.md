# 운영체제

###### 사용자(user)

###### 응용 프로그램(Application)

- 사용자 프로그램
- 개발 시 운영체제 기능이 필요한 경우, 해당 운영체제의 API를 사용하여 프로그램 작성
- CPU 외 다양한 하드웨어를 사용 (-> **멀티 프로그래밍**과 관련)
- 실행 시 해당 API를 호출
  - 시스템 콜 호출, **커널 모드**로 변경
  - 운영체제 내부에서 해당 명령이 실행되고, 응용 프로그램에 결과를 리턴

###### 운영체제(OS, Operating System)

- 주요 운영체제: 윈도우, 리눅스/UNIX, MacOS
- 프로세스 관리, 주기억장치 관리, 파일 관리, 디스크 관리, 입출력 관리, 네트워킹 및 보호/보안
- 사용자 인터페이스(**쉘,** Shell)를 제공
  - 쉘
    - 사용자가 운영체제 기능과 서비스를 조작할 수 있도록 인터페이스를 제공하는 프로그램
    - CLI(터미널) 환경과 GUI 환경으로 분류
- 응용 프로그램 인터페이스(**시스템 콜**, System Call)를 제공
  - 시스템 콜 (또는 시스템 호출 인터페이스)
    - 운영체제가 운영체제의 각 기능을 사용하도록 명령 또는 함수를 제공
    - API 내부에는 시스템 콜을 호출하는 형태로 만들어지는 경우가 대부분
    - 커널 모드로 실행
- 프로그래밍 언어별 운영체제 지원을 위해, 운영체제 별 **API** 제공

###### 컴퓨터 하드웨어(Hardware)



## CPU Protection Ring

###### 사용자 모드(user mode)

- 응용 프로그램이 사용

###### 커널 모드(kernel mode)

- 함부로 응용 프로그램이 전체 컴퓨터 시스템을 헤치지 못함

- 운영체제가 사용
- 커널 모드로 실행하려면, 반드시 (운영체제가 제공하는) 시스템 콜을 거쳐야 함



## 프로세스(Process) vs 스레드(Thread)

|         프로세스         |        스레드        |
| :----------------------: | :------------------: |
|          독립적          |  프로세스의 서브셋   |
|   독립적인 자원을 가짐   | 프로세스 자원을 공유 |
| 자신만의 주소영역을 가짐 |   주소영역을 공유    |
|    IPC 기법으로 통신     |  IPC 기법 필요 없음  |



## 프로세스(Process)

(메모리에 올려져서) 실행 중인 프로그램

응용 프로그램은 여러 프로세스로 구성 가능

작업, task, job 용어와 혼용

코드 이미지(바이너리 코드): 실행 파일프로세스(Process) vs 스레드(Thread)



###### 프로세스와 컴퓨터 구조: **PC + SP**

- PC(Program Coutner): 다음 실행할 코드 주소(실행 코드 라인)
- SP(Stack Pointer): 스택 최상단 주소(위치)

- 리눅스의 프로세스
  - 커널 공간은 공유
  - 어떤 프로세스나 0~4GB까지의 메모리 주소를 가짐



## 프로세스 간 통신

프로세스 간에는 각 프로세스의 데이터 접근 불가

여러 프로세스를 만들어 동시에 실행하기 위해 프로세스 간 상태 확인 및 데이터 송수신이 필요

여러 프로세스의 동시 실행을 통한 성능 개선과 복잡한 프로그램을 위해 필요



###### **IPC(InterProcess Communication)**

- 프로세스 간 공간이 분리되어  있어, 통신을 위한 특별한 기법이 필요

- 프로세스 간 통신 방법을 제공

- IPC 기법

  - file 사용: 실시간으로 직접 원하는 프로세스에 데이터를 전달하는 것이 어려움

  - 대부분의 경우, **커널 공간을 활용**(공유)

    - Shared Memory(공유 메모리): 커널 공간에 메모리 공간을 만들어 해당 공간을 변수처럼 씀

    - Message Queue, Pipe, Signal, Semaphore, Socket, ...



## 프로세스 스케쥴링

###### 배치 처리 시스템

- 여러 프로그램을 순차적으로 실행
- 어떤 프로그램의 실행 시간이 많이 걸리면, 다른 프로그램이 실행하는데 시간을 많이 기다려야 함
- 교착상태(deadlock)가 일어나지 않음



###### 시분할 시스템

- (여러 사용자가 동시에 하나의 컴퓨터를 쓰도록) 다중 사용자 지원
- 컴퓨터 응답 시간을 최소화



###### 멀티 태스킹

- **단일 CPU**에서 여러 응용 프로그램을 동시에 실행하는 것처럼 보이도록 함
- 10~30ms 단위로도 실행 응용 프로그램이 바뀜
- MP3 음악을 들으면서 문서 작성하기, 등



###### 멀티 프로그래밍

- 최대한 CPU를 (일정시간당) 많이 활용하도록 함
- Wait: 간단히 저장매체로부터 파일 읽기를 기다리는 시간으로 가정



###### 멀티 프로세싱

- **여러 CPU**에 하나의 응용 프로그램을 병렬로 실행하여 실행 속도를 극대화
- 처음 구조를 잡을 때 만들어야 함
- 인스턴스 간, 공유된 자원 간의 읽고 쓰기가 빈번한 경우 사용하기에 적합



## 프로세스 상태

running: 현재 CPU에서 **실행** 상태

ready: CPU에서 실행 **가능** 상태 (실행 대기 상태)

block: 특정 이벤트 발생 **대기** 상태



###### 프로세스 상태 간 관계

1. running->block: 입력을 위해 프로세스 대기
2. ready->running: 스케쥴러가 다른 프로세스를 찍음
3. running->ready: 스케쥴러가 이 프로세스를 찍음
4. block->ready: 프로세스가 실행 가능해짐



## 프로세스 구조

stack: 임시 데이터(함수 호출, 로컬 변수 등)

heap: 코드에서 동적으로 만들어지는 데이터

data: 변수/초기화된 데이터

text(CODE): 코드



## 컨텍스트 스위칭(Context Switching, 또는 문맥 교환)

CPU에 실행할 **프로세스를 교체**하는 기술

PC, SP만 바꿔주면 프로세스 저장 상태를 기반으로 실행 가능

실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트하여 **메인 메모리에 저장**

다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB 정보(PC, SP)를 CPU의 레지스터에 넣고 실행(**메인 메모리에서 로드**)



## PCB(Process Control Block)

PCB에 다음 프로세스 정보(Process ID, Register, 등)를 저장

프로세스가 실행 중인 상태를 캡쳐/구조화하여 저장



## 스레드(Thread)

Light Weight Process

하나의 프로세스에 여러 개의 스레드 생성 가능

여러 스레드를 동시에 실행 가능하며, 각기 실행 가능한 stack이 존재



###### 장점

- CPU 활용도를 높이고, 성능 개선 가능
- 사용자에 대한 응답성 향상
- 자원 공유의 효율성
  - 스레드 간 자원 공유가 가능하기 때문에, IPC를 쓰지 않아도 됨
  - 프로세스 안에 있기 때문에, 프로세스의 데이터를 모두 접근 가능
- 작업이 분리되어 코드가 간결해질 수 있음



###### 단점

- (프로세스와 달리) 스레드 중 한 스레드만 문제가 있어도 전체 프로세스가 영향을 받음

- 많이 생성하면 컨텍스트 스위칭이 많이 일어나 성능 저하

  - 리눅스 운영체제의 경우
    - 스레드를 프로세스와 같이 다룸
    - 모든 스레드를 스케쥴링해야 하므로, 컨텍스트 스위칭이 빈번할 수밖에 없음

- **동기화(Synchronization)** 이슈

  - 동기화: 작업들 사이에 실행 시기를 맞추는 것

  - 여러 스레드가 동일한 자원(데이터)을 접근할 시, 비정상적으로 동작할 수 있음

  - 여러 스레드가 동일한 자원을 동시에 수정할 시, 각 스레드 결과에 영향을 줌

  - 해결 방안: **상호 배제**(Mutual exclusion)

    - 동기화 코드를 적절히 추가

    - 프로세스의 모든 데이터를 접근할 수 있기 때문에, 여러 스레드가 변경하는 공유 변수에 대해 Exclusive access 필요
    - 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시에 접근하지 못하도록 막음
    - 임계 자원(critical resource)과 임계 구역(critical section)

  - 임계 구역에 대한 접근을 막기 위한 LOCKING 매커니즘

    - **Semaphore**(세마포어)
      - 임계구역에 여러 스레드가 들어갈 수 있음
      - counter을 두어 동시에 리소스에 접근할 수 있는 허용 가능한 스레드 수를 제어
    - Mutex(binary semaphore)
      - 임계구역에 하나의 스레드만 들어갈 수 있음



###### 교착상태(deadlock)

- 무한 대기 상태
- 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있어 다음 단계로 진행하지 못하는 상태
- 프로세스, 스레드 모두 일어날 수 있음
- 여러 프로세스가 동일한 자원의 점유를 요청할 때 발생
- 발생 조건
  - 상호 배제(Mutual exclusion): 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구
  - 점유 대기(Hold and wait): 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다림
  - 비선점(No preemption): 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없음
  - 순환 대기(Circular wait): 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있음



###### 기아상태(starvation)

- 특정 프로세스의 우선순위가 낮아 원하는 자원을 계속 할당받지 못하는 상태
- 여러 프로세스가 부족한 자원의 점유를 위해 경쟁할 때, 특정 프로세스는 영원히 자원 할당이 안되는 상태
- 해결 방안: 우선순위 변경
  - 프로세스 우선순위를 수시로 변경
  - 각 프로세스가 높은 우선순위를 가질 기회를 줌
  - 오래 기다린 프로세스의 우선순위를 높여줌
  - 우선순위가 아닌, 요청 순서대로 처리하는 FIFO 기반 요청큐 사용



## 멀티 스레드(Multi Thread)

소프트웨어의 병행 작업 처리를 위해 사용 (Code 영역 공유)

스레드 간 자원 공유 가능

스레드 간 별도의 통신 오버헤드가 적음

공유된 자원 간 읽고 쓰기가 빈번할 경우, 추가적인 오버헤드가 드는 동기화 기법을 사용해야 함

공유된 자원 간 쓰기가 없는 경우 사용하기에 적합

- 동기화 기법을 적용할 필요가 없음

최근 CPU는 멀티 코어를 가지므로, 스레드를 여러 개 만들어 멀티 코어의 활용도를 높임

프로그램의 일부 동작에서만 사용하도록 일부 코드를 수정함으로써 만들 수 있음



## 가상 메모리(Virtual Memory System)

각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기의 한계가 있음



## 컴퓨터 시스템 구성

하드웨어(Hardware): CPU(중앙처리장치), Memory, Storage, Network, 등

소프트웨어(Software): 운영체제, 응용 프로그램



## 컴퓨터 주요 구성요소

###### CPU(Central Processor Unit)

- 연산: ALU(Arithmetic Logic Unit)
  - 산술 연산(Arithmetic Operation)과 논리 연산(Logic Operation)
- 제어: Control Device
  - 입출력 장치(IO Device), Memory, ALU 동작을 제어



###### 메모리

- 코드와 데이터를 저장하는 장치
- 프로그램과 프로그램 수행에 필요한 데이터를 저장
- 내부 기억장치(주기억장치)
  - CPU 안 레지스터(register), 캐쉬(cache memory)
  - DRAM 등 메모리(RAM, DDR4)
- 외부 기억장치(보조기억장치)
  - SSD, HDD



###### 입출력 장치(IO Devices)

- 입력 장치: 마우스, 키보드, 터치패드, 등
- 출력 장치: 모니터, 프린터, 스피커, 등



###### 버스(Bus)

- CPU, 메모리, 입출력 장치를 연결해주는 장치
- 개별 입출력 장치들을 연결해주고 데이터를 송수신해줌



## 폰노이만 구조

CPU, 메모리, 프로그램으로 구성 (소프트웨어만 교체하면 됨)

코드는 반드시 메모리에 있어야 함

메모리에 프로그램과 데이터가 저장

하나씩 꺼내어 CPU(ALU)로 연산 (CPU에서 실행)



## 페이징(paging)

크기가 동일한 페이지로 가상주소 공간과 (이에 매칭하는) 물리주소 공간을 관리

하드웨어의 지원 필요

- Intel x86 시스템(32bit)에서는 4KB, 2MB, 1GB 지원
- 리눅스에서는 4KB 지원

페이지 번호 기반으로 가상주소와 물리주소의 매핑정보를 기록하고 사용



## 페이징 시스템(paging system)

###### 구조

- 페이지(page 또는 page frame): 고정된 크기의 block (4KB)

- 가상주소(Virtual Address) v = (p, d)

  - p: 가상 메모리 페이지. 페이지 번호

  - d: p 안에서 참조하는 위치. 변위(오프셋). 페이지 처음부터 얼마 떨어진 위치인지

- 페이지 크기가 4KB라면

  - 변위 d는 가상주소의 0 ~ 11비트

  - 페이지 번호 p는 12비트 이상



###### 페이지 테이블(Page Table)

- 프로세스의 PCB에 페이지 테이블 구조체를 가리키는 주소가 들어있음

- 가상주소와 물리주소 간 매핑 정보가 있음

- 물리주소에 있는 페이지 번호와 해당 페이지의 첫 물리주소 정보를 매핑한 표



###### 동작

- 해당 프로세스에서 특정 가상주소에 접근하려면
  - 해당 프로세스의 페이지 테이블에 해당 가상주소가 포함된 페이지 번호가 있는지 확인
  - 페이지 번호가 있으면, 이 페이지가 매핑된 첫 물리주소(p')를 알아냄
  - 실제 물리주소는 p' + d가 됨



###### 공유 메모리(IPC)

- 프로세스 간 동일한 물리주소를 가리킬 수 있음

- 공간과 메모리 할당 시간을 절약



## MMU

CPU -`{가상주소}`-> MMU -`{물리주소}`-> Memory

CPU는 가상주소에 접근할 때, MMU 하드웨어 장치를 통해 물리메모리에 접근

프로세스 생성 시, 페이지 테이블 정보를 생성

- PCB 등에서 해당 페이지 테이블에 접근 가능
- 관련 정보는 물리 메모리에 적재
- 프로세스 구동 시, 해당 페이지 테이블의 base 주소가 별도 레지스터(CR3)에 저장
- CPU가 가상주소에 접근 시, MMU가 페이지 테이블의 base 주소를 접근해 물리주소를 가져옴



## 다중 단계 페이징 시스템

미리 페이징 정보를 만들어놓지 않고, 특정 페이징 주소 영역(디렉토리)에 대해서만 만들어놓음

페이징 정보를 단계를 나누어 생성

- 필요없는 페이지는 (생성하지 않으면) 공간을 절약할 수 있음
- 페이지 번호를 나타내는 bit를 구분해서 단계를 나눔

32bit 시스템에서 4KB 페이지를 위한 페이징 시스템의 경우,

- 하위 12bit는 오프셋, 상위 20bit는 페이징 번호
- 2의 20승개의 페이지 정보가 필요



## TLB(Translation Lookaside Buffre)

페이지 정보 캐시

MMU <-`{물리주소 전달 및 캐싱}`-> TLB

MMU가 물리주소를 확인하기 위해서 메모리를 갔다와야 함

1. CPU -`{가상주소 요청}`-> MMU
2. MMU -`{base주소 CR3}`-> 메모리 (프로세스 A 페이지 테이블)
3. 메모리 (프로세스 A 페이지 테이블) -`{물리주소 요청}`-> MMU
4. MMU -`{물리주소 접근}`-> 메모리 (프로세스 A 페이지 #5)
5. 메모리 (프로세스 A 페이지 #5) -`{데이터 전달}`-> CPU



## cycle

1개의 세부 작업을 하는 단위

하나의 명령을 실행하는 데 5 cycle

- 1Hz = 1 cycle / sec
- 최초 인텔 CPU 4004: 108KHz (108,000Hz)
- 108,000 / 5 cycle = 초당 21,600 명령 실행



## 파이프라인

하나의 작업(명령 실행)에 필요한 일을 세부적으로 나눔 + 동시에 다른 세부 작업을 실행

- 명령어 인출(IF, Instruction Fetch)
- 명령어 해독(ID, Instruction Decode): 인출된 명령어를 해석
- 오퍼랜드 인출(OF, Operand Fetch): 메모리에서 데이터를 인출
- 명령어 실행(EX, EXecute)
- 실행결과 저장(SR, STore)

CPU 성능을 높임



## 요구 페이징(Demand(ed) Paging)

프로세스의 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재

선행 페이징(anticipatory paging or prepaging)의 반대 개념

- 선행 페이징: 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행

**페이지 교체 알고리즘** 필요

- 더이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장



## 페이지 폴트(page fault)

어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트

운영체제가 페이지 폴트가 일어나면, 해당 페이지를 물리 메모리에 올림



###### 인터럽트

1. CPU -{`가상주소 요청`}-> MMU
2. MMU -{`base주소 CR3`}-> 메모리 (프로세스 A 페이지 테이블)
3. 메모리 (프로세스 A 페이지 테이블) -{`물리주소 페이지 폴트 인터럽트에 타당하지 않음`}-> 운영체제
   - 운영체제는 페이지 폴트 인터럽트 핸들링
4. 운영체제 -{`저장매체에 페이지 블록 발견`}-> 저장매체 (프로세스 A 페이지 #5)
5. 저장매체 (프로세스 A 페이지 #5) -{`메모리에 페이지 블록 업로드`}-> 메모리 (프로세스 A 페이지 #5)
6. 메모리 (프로세스 A 페이지 #5) -{`페이지 테이블 업데이트`}-> 메모리 (프로세스 A 페이지 테이블)
7. CPU -{`가상주소 요청 재시작`}-> MMU



## 인터럽트

CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어(IO Device) 등 장치 또는 예외상황 발생

CPU에 알려서 처리



## 인터럽트가 필요한 이유

IO Device와 커뮤니케이션

- 저장매체에서 데이터 처리 완료 시, 프로세스를 깨워야 함
- block state -> ready state



## 인터럽트 종류

내부 인터럽트

외부 인터럽트